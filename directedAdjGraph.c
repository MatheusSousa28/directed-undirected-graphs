#include <stdio.h>
#include <stdlib.h>
//colors of the vertices during the DFS algorithm
#define WHITE 1 //a white vertex has never been visited
#define GRAY 2 //a gray vertex has been visited but still has unexplored connections
#define BLACK 3 //a black vertex has been fully visited and has no remaining unexplored connections
typedef struct Vert{
    int data;
    struct Vert* next;//pointer to the next vertex in the adjacency list
    struct Vert* prnt;//pointer to the parent vertex used to reach this vertex
    int d;//vertex discovery time
    int color;
    int f;//vertex finishing time
}Vert;
typedef struct Graph{
    int numVerts;//number of vertices in the graph
    Vert* *adjLists;//each position of this double pointer (this works like an array) stores the head of the adjacency list for the vertex corresponding to that position
    Vert* *vertices;//it stores the original vertices whose colors will actually change during the DFS algorithm
}Graph;
Vert* createVert(int data);
Graph* createGraph(int numVertices);
void addEdge(Graph* graph, int src, int dest);
void printGraph(Graph* graph);
void DFS(Graph* graph);
void DFSvisit(Graph* graph, Vert* *u, int* time);
void printTree(Graph* graph);
void printSubTree(Graph* graph, Vert* v, int level);
void destroy(Graph* graph);
int main(){
    Graph* graph = createGraph(6);//creating a graph with six vertices
    //adding edges between the vertices
    addEdge(graph, 0 , 1);
    addEdge(graph, 0 , 3);
    addEdge(graph, 3 , 1);
    addEdge(graph, 1 , 4);
    addEdge(graph, 4 , 3);
    addEdge(graph, 2 , 4);
    addEdge(graph, 2 , 5);
    addEdge(graph, 5 , 5);
    printGraph(graph);//displaying the adjacency list of each vertex in the graph
    DFS(graph);//initializing the DFS algorithm
    printTree(graph);//displaying the tree generated by the DFS algorithm (this tree is just a representation of the graph)
    destroy(graph);//releasing all memory allocated throughout the program
    return 0;
}
Vert* createVert(int data){
    //creating a new vertex and initializing its fields
    Vert* newVert = (Vert*)malloc(sizeof(Vert));
    newVert->data = data;
    newVert->next = NULL;
    newVert->prnt = NULL;
    newVert->d = -1;
    newVert->color = WHITE;
    newVert->f = -1;
    return newVert;//returning the new vertex
}
Graph* createGraph(int numVertices){
    //creating a graph and allocating two double pointers that will work like arrays
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVerts = numVertices;
    //the size of the double pointers is equal to the number of vertices in the graph
    graph->adjLists = (Vert**)malloc(numVertices * sizeof(Vert*));
    graph->vertices = (Vert**)malloc(numVertices * sizeof(Vert*));
    for(int i = 0; i < numVertices; i++){//the variable i will take values from 0 up to the number of vertices in the graph minus 1
        graph->adjLists[i] = NULL;//initializing each position of the adjacency list with a null value
        graph->vertices[i] = createVert(i);//creating vertices at each position of the double pointer array with the value of i
    }
    return graph;//returnig the graph 
}
void addEdge(Graph* graph, int src, int dest){
    //src is the vertex that will include the dest vertex in its adjacency list
    Vert* v1 = graph->vertices[dest];//getting the reference to the dest vertex

    Vert* new = createVert(v1->data);//creating a new vertex with the same data as the dest vertex
    new->next = graph->adjLists[src];//the new vertex points to the g of the adjacency list of the src vertex
    graph->adjLists[src] = new;//the pointer at this position now points to the new vertex, making it the first element of the adjacency list of the src vertex
}
void printGraph(Graph* graph){
    for(int i = 0; i < graph->numVerts; i++){
        printf("[%d]",i);//displaying the data of the vertex
        Vert* temp = graph->adjLists[i];//starts in the beginning of the adjacency list of each vertex
        while (temp){//displaying each vertex in the adjacency list 
            printf(" %d ->",temp->data);
            temp = temp->next;
        }
        printf("\n");
    }
}
void DFS(Graph* graph){
    for(int i = 0; i < graph->numVerts; i++){
        //painting all vertices white and initializing their parent with null 
        graph->vertices[i]->color = WHITE;
        graph->vertices[i]->prnt = NULL;
    }
    int time = 0;//initializing the time
    for(int i = 0; i < graph->numVerts; i++){
        //this outer loop of the visit function allows us to reach all vertices in the graph, even those that are not accessible from any other vertex. 
        //this process may result in the creation of multiple trees.
        Vert* u = graph->vertices[i];
        if(u->color == WHITE)//traversing all vertices while searching for white vertices
            DFSvisit(graph, &u, &time);//calling the visit function, passing this white vertex and the current time
    }
}
void DFSvisit(Graph* graph, Vert* *u, int* time){
    (*time)++;//incrementing the time
    (*u)->d = *time;//setting the vertex discovery time to the current time
    (*u)->color = GRAY;//the vertex is now gray because it has already been discovered
    Vert* adj = graph->adjLists[(*u)->data];//getting the reference to the beginning of the vertex's adjacency list
    while(adj){//traversing all the vertex's adjacency list
        Vert* v = graph->vertices[adj->data];//v is the reference to the original vertex corresponding to this vertex in the adjacency list
        if(v->color == WHITE){//if this vertice v is white
            v->prnt = *u;//Now the parent of vertex v is vertex u, which was used to reach this vertex
            DFSvisit(graph, &v, time);//calling the visit function recursively, passing the vertex v and the current time
        }
        adj = adj->next;
    }
    (*u)->color = BLACK;//once the entire adjacency list of vertex u has been explored, it is painted black because there are no more connections to explore
    (*time)++;//incrementing the time again
    (*u)->f = *time;//setting the vertex finishing time to the current time
}
void printTree(Graph* graph) {
    for (int i = 0; i < graph->numVerts; i++) {
        Vert* v = graph->vertices[i];
        //root of a tree, (has no parent)
        if (v->prnt == NULL && v->color != WHITE) {
            printf("\nroot of the tree\n");
            printSubTree(graph, v, 0);//calling the function that will display the rest of the tree starting from this vertex
        }
    }
}
void printSubTree(Graph* graph, Vert* v, int level) {
    for (int i = 0; i < level; i++) {
        //this level is used to make visualizing the trees easier
        printf("    ");  //4 spaces per level
    }
    printf("%d\n", v->data);
    //displays the children of vertex v
    for (int i = 0; i < graph->numVerts; i++) {
        Vert* son = graph->vertices[i];
        if (son->prnt == v) {
            //calling the function recursively incremeting the level
            printSubTree(graph, son, level + 1);
        }
    }
}
void destroy(Graph* graph){
    for(int i = 0; i < graph->numVerts; i++){
        Vert* temp = graph->adjLists[i];
        while (temp){
            //traversing each vertex's adjacency list and freeing its elements
            Vert* d = temp;
            temp = temp->next;
            free(d);
        }
        free(graph->vertices[i]);//freeing the original vertices
    }
    //freeing the double pointers and numVerts
    free(graph->adjLists);
    free(graph->vertices);
    free(graph);
}