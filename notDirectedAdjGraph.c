#include <stdio.h>
#include <stdlib.h>
//colors of the vertices during the BFS algorithm
#define WHITE 1 //a white vertex has never been visited
#define GRAY 2 //a gray vertex has been visited but still has unexplored connections
#define BLACK 3 //a black vertex has been fully visited and has no remaining unexplored connections
typedef struct Vert{
    int data;
    struct Vert* next;//pointer to the next vertex in the adjacency list
    struct Vert* prnt;//pointer to the parent vertex used to reach this vertex
    int d;//distance of the vertex from the starting vertex
    int color;
    struct Vert* fnext;//pointer to the next vertex in the queue used in BFS algorithm
}Vert;
typedef struct Graph{
    int numVerts;//number of vertices in the graph
    Vert* *adjLists;//each position of this double pointer (this works like an array) stores the head of the adjacency list for the vertex corresponding to that position
    Vert* *vertices;//it stores the original vertices whose colors will actually change during the DFS algorithm
}Graph;
Vert* createVert(int data);
Graph* createGraph(int numVertices);
void addEdge(Graph* graph, int src, int dest);
void printGraph(Graph* graph);
void BFS(Graph* graph, Vert* s);
void queue(Vert* *Q, Vert* s);
Vert* unqueue(Vert* *Q);
void printTree(Graph* graph);
void printSubTree(Graph* graph, Vert* v, int level);
void destroy(Graph* graph);
int main(){
    Graph* graph = createGraph(8);//creating a graph with eight vertices
    //adding edges between the vertices
    addEdge(graph, 0, 1);
    addEdge(graph, 0 , 4);
    addEdge(graph, 1, 5);
    addEdge(graph, 5 , 2);
    addEdge(graph, 5 , 6);
    addEdge(graph, 6 , 2);
    addEdge(graph, 6 , 3);
    addEdge(graph, 6 , 7);
    addEdge(graph, 7, 3);
    addEdge(graph, 2, 3);
    printGraph(graph);//displaying the adjacency list of each vertex in the graph
    BFS(graph, graph->vertices[1]);//initializing the BFS algorithm passing a starting vertex
    printTree(graph);//displaying the tree generated by the BFS algorithm (this tree is just a representation of the graph)
    destroy(graph);//releasing all memory allocated throughout the program
    return 0;
}
Vert* createVert(int data){
    //creating a new vertex and initializing its fields
    Vert* newVert = (Vert*)malloc(sizeof(Vert));
    newVert->data = data;
    newVert->next = NULL;
    newVert->prnt = NULL;
    newVert->d = -1;
    newVert->color = WHITE;
    newVert->fnext = NULL;
    return newVert;//returning the new vertex
}
Graph* createGraph(int numVertices){
    //creating a graph and allocating two double pointers that will work like arrays
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVerts = numVertices;
    //the size of the double pointers is equal to the number of vertices in the graph
    graph->adjLists = (Vert**)malloc(numVertices * sizeof(Vert*));
    graph->vertices = (Vert**)malloc(numVertices * sizeof(Vert*));
    for(int i = 0; i < numVertices; i++){//the variable i will take values from 0 up to the number of vertices in the graph minus 1
        graph->adjLists[i] = NULL;//initializing each position of the adjacency list with a null value
        graph->vertices[i] = createVert(i);//creating vertices at each position of the double pointer array with the value of i
    }
    return graph;//returnig the graph 
}
void addEdge(Graph* graph, int src, int dest){
    //in undirected graphs, both the src and dest vertices are added to each other's adjacency lists
    
    //getting the references of both src and dest vertices
    Vert* v1 = graph->vertices[src];
    Vert* v2 = graph->vertices[dest];

    Vert* new = createVert(v1->data);//creating a new vertex with the same data as the src vertex
    new->next = graph->adjLists[dest];//the new vertex points to the beginning of the adjacency list of the dest vertex
    graph->adjLists[dest] = new;//the pointer at this position now points to the new vertex, making it the first element of the adjacency list of the dest vertex

    new = createVert(v2->data);//creating a new vertex with the same data as the dest vertex
    new->next = graph->adjLists[src];//the new vertex points to the beginning of the adjacency list of the src vertex
    graph->adjLists[src] = new;//the pointer at this position now points to the new vertex, making it the first element of the adjacency list of the src vertex
}
void printGraph(Graph* graph){
    for(int i = 0; i < graph->numVerts; i++){
        printf("[%d]",i);//displaying the data of the vertex
        Vert* temp = graph->adjLists[i];//starts in the beginning of the adjacency list of each vertex
        while (temp){//displaying each vertex in the adjacency list 
            printf(" %d ->",temp->data);
            temp = temp->next;
        }
        printf("\n");
    }//position
}
void BFS(Graph* graph, Vert* s){
    //painting all vertices white, initializing their parent with null and their distance with -1
    for(int i = 0; i < graph->numVerts; i++){
        graph->vertices[i]->color = WHITE;
        graph->vertices[i]->d = -1;
        graph->vertices[i]->prnt = NULL;
    }
    //painting the starting vertex gray, setting its distance to 0, and its parent to null
    s->color = GRAY;
    s->d = 0;
    s->prnt = NULL;
    Vert* Q = NULL;//creating and initializing the queue that will be used to store the gray vertices
    queue(&Q, s);//enqueuing the starting vertex
    while(Q != NULL){//this loop will continue until the queue is completely empty
        Vert* u = unqueue(&Q);//dequeuing the first vertex in the queue, referred to as vertex u
        Vert* adj = graph->adjLists[u->data];//getting the reference to the beginning of the vertex's u adjacency list
        while(adj){//traversing the entire adjacency list of vertex u looking for white vertices
            Vert* v = graph->vertices[adj->data];//getting the reference to the original vertex corresponding to this vertex in adjacency list
            if(v->color == WHITE){
                v->color = GRAY;//painting gray the vertex v
                v->d = u->d + 1;//setting the distance of vertex v to the distance of vertex u + 1, because vertex u was used to reach vertex v, making u the parent of v
                v->prnt = u;
                queue(&Q, v);//enqueuing vertex v because it is now gray
            }
            adj = adj->next;//moving to the next vertex in the adjacency list of vertex u
        }
        u->color = BLACK;//after the entire adjacency list of vertex u has been fully traversed, it is painted black because it has no remaining connections
    }
}
void queue(Vert* *Q, Vert* s){
    if(*Q == NULL){
        *Q = s;//if the queue is empty, vertex s is placed at the beginning of the queue
    }else{
        //if it is not empty, we must traverse the queue to place vertex s at its last position
        Vert* temp = *Q;//getting the reference to the begining of the queue
        while(temp->fnext != NULL)//traversing the queue
            temp = temp->fnext;
        temp->fnext = s;//the last position in the queue now points to vertex s, making it the new last element
    }
}
Vert* unqueue(Vert* *Q){
    Vert* x = *Q;//getting the reference to the first element in the queue
    *Q = (*Q)->fnext;//updating the queue pointer to point to the second element in the queue
    x->fnext = NULL;//the fnext pointer of the first element no longer points to the second element and now points to null
    return x;//returning the first element
}
void printTree(Graph* graph) {
    for (int i = 0; i < graph->numVerts; i++) {
        Vert* v = graph->vertices[i];
        //root of a tree, (has no parent)
        if (v->prnt == NULL && v->color != WHITE) {
            printf("\nroot of the tree\n");
            printSubTree(graph, v, 0);//calling the function that will display the rest of the tree starting from this vertex
        }
    }
}
void printSubTree(Graph* graph, Vert* v, int level) {
    for (int i = 0; i < level; i++) {
        //this level is used to make visualizing the trees easier
        printf("    ");  //4 spaces per level
    }
    printf("%d\n", v->data);
    //displays the children of vertex v
    for (int i = 0; i < graph->numVerts; i++) {
        Vert* son = graph->vertices[i];
        if (son->prnt == v) {
            //calling the function recursively incremeting the level
            printSubTree(graph, son, level + 1);
        }
    }
}
void destroy(Graph* graph){
    for(int i = 0; i < graph->numVerts; i++){
        Vert* temp = graph->adjLists[i];
        while (temp){
            //traversing each vertex's adjacency list and freeing its elements
            Vert* d = temp;
            temp = temp->next;
            free(d);
        }
        free(graph->vertices[i]);//freeing the original vertices
    }
    //freeing the double pointers and numVerts
    free(graph->adjLists);
    free(graph->vertices);
    free(graph);
}